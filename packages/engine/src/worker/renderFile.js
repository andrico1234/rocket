import path from 'path';
// import { mdjsProcess } from '@mdjs/core';
import { parentPort } from 'worker_threads';
import { mkdir, readFile, unlink, writeFile } from 'fs/promises';
import { existsSync } from 'fs';
import {
  sourceRelativeFilePathToOutputRelativeFilePath,
  sourceRelativeFilePathToUrl,
} from '../urlPathConverter.js';
import { convertMdFile } from '../converts.js';
import { transformFile } from '../helpers/transformFile.js';

import { litServerRender } from '../helpers/litServerRender.js';

/**
 * @param {string} filePath
 */
async function cleanupAutoGeneratedMdFiles(filePath) {
  const mdInJsFilePath = filePath.replace('.rocket.md', '.rocketGeneratedMdInJs.js');
  const jsTemplateFilePath = filePath.replace('.rocket.md', '.rocketGeneratedFromMd.js');

  if (existsSync(mdInJsFilePath)) {
    await unlink(mdInJsFilePath);
  }
  if (existsSync(jsTemplateFilePath)) {
    await unlink(jsTemplateFilePath);
  }
}

async function renderFile({
  writeFileToDisk = true,
  filePath,
  outputDir,
  renderMode = 'development',
}) {
  let toImportFilePath = filePath;
  if (filePath.endsWith('.rocket.md')) {
    toImportFilePath = await convertMdFile(filePath);
  }
  const { default: content, ...data } = await import(toImportFilePath);
  const { sourceRelativeFilePath, layout, openGraphLayout } = data;

  if (typeof content !== 'function') {
    throw new Error(
      `The file ${sourceRelativeFilePath} should return a function but returned a ${typeof content}`,
    );
  }

  const outputRelativeFilePath = sourceRelativeFilePathToOutputRelativeFilePath(
    sourceRelativeFilePath,
  );
  const outputFilePath = path.join(outputDir, outputRelativeFilePath);

  const url = sourceRelativeFilePathToUrl(sourceRelativeFilePath);
  let openGraphData = {};
  if (openGraphLayout && outputFilePath.endsWith('.html')) {
    openGraphData = {
      openGraphOutputFilePath: outputFilePath.replace(/\.html$/, '.opengraph.html'),
      openGraphOutputRelativeFilePath: outputRelativeFilePath.replace(/\.html$/, '.opengraph.html'),
      openGraphUrl: url.replace(/\.html$/, '.opengraph.html'),
    };
  }
  const layoutData = {
    sourceFilePath: filePath,
    outputFilePath,
    sourceRelativeFilePath,
    outputRelativeFilePath,
    url,
    renderMode,
    content,
    ...openGraphData,
    ...data,
  };
  let fileContent = content;

  // try {
  let templateResult;
  if (layout) {
    templateResult =
      typeof layout.render === 'function' ? layout.render(layoutData) : layout(layoutData);
  } else {
    templateResult = content();
  }

  if (typeof templateResult === 'string') {
    fileContent = templateResult;
  } else {
    fileContent = await litServerRender(templateResult);
  }
  // } catch (e) {
  //   console.log(`Error writing ${sourceRelativeFilePath}`);
  // }

  fileContent = await transformFile(fileContent, {
    setupPlugins: data.setupEnginePlugins,
    sourceFilePath: filePath,
    outputFilePath,
    sourceRelativeFilePath,
    outputRelativeFilePath,
    url,
  });

  if (writeFileToDisk) {
    if (!existsSync(path.dirname(outputFilePath))) {
      await mkdir(path.dirname(outputFilePath), { recursive: true });
    }
    // console.log(`Writing: ${outputRelativeFilePath}`);
    await writeFile(outputFilePath, fileContent);
  }

  if (openGraphLayout && outputFilePath.endsWith('.html')) {
    const openGraphTemplateResult =
      typeof openGraphLayout.render === 'function'
        ? openGraphLayout.render(layoutData)
        : openGraphLayout(layoutData);
    const openGraphHtml = await litServerRender(openGraphTemplateResult);
    // console.log(`Writing Open Graph: ${openGraphOutputFilePath}`);
    await writeFile(layoutData.openGraphOutputFilePath, openGraphHtml);
  }

  if (filePath.endsWith('.rocket.md')) {
    await cleanupAutoGeneratedMdFiles(filePath);
  }

  parentPort.postMessage({
    status: 200,
    outputFilePath,
    fileContent,
    filePath,
    sourceRelativeFilePath,
  });
}

parentPort.on('message', message => {
  if (message.action === 'renderFile') {
    const { filePath, outputDir, renderMode } = message;
    renderFile({ filePath, outputDir, renderMode });
  }
});
